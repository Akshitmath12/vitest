// Test generated by RoostGPT for test ReactStoryBook using AI Type Open AI and AI Model gpt-4

const mockSendToClient = jest.fn();
const mockUnregister = jest.fn();
const INTEGRITY_CHECKSUM = 'test_checksum';

global.self = {
  addEventListener: jest.fn(),
  clients: {
    get: jest.fn(),
    matchAll: jest.fn(),
  },
  registration: {
    unregister: mockUnregister,
  },
};

jest.mock('./mockServiceWorker', () => ({
  sendToClient: mockSendToClient,
}));

const { addEventListener } = require('./mockServiceWorker');

describe('mockServiceWorker', () => {
  beforeEach(() => {
    mockSendToClient.mockClear();
    mockUnregister.mockClear();
    global.self.clients.get.mockClear();
    global.self.clients.matchAll.mockClear();
  });

  test('should handle KEEPALIVE_REQUEST message', async () => {
    const client = {
      id: 'test_id',
    };
    global.self.clients.get.mockResolvedValue(client);
    global.self.clients.matchAll.mockResolvedValue([client]);

    await addEventListener('message', {
      source: {
        id: client.id,
      },
      data: 'KEEPALIVE_REQUEST',
    });

    expect(mockSendToClient).toHaveBeenCalledWith(client, { type: 'KEEPALIVE_RESPONSE' });
  });

  test('should handle INTEGRITY_CHECK_REQUEST message', async () => {
    const client = {
      id: 'test_id',
    };
    global.self.clients.get.mockResolvedValue(client);
    global.self.clients.matchAll.mockResolvedValue([client]);

    await addEventListener('message', {
      source: {
        id: client.id,
      },
      data: 'INTEGRITY_CHECK_REQUEST',
    });

    expect(mockSendToClient).toHaveBeenCalledWith(client, { type: 'INTEGRITY_CHECK_RESPONSE', payload: INTEGRITY_CHECKSUM });
  });

  test('should handle MOCK_ACTIVATE message', async () => {
    const client = {
      id: 'test_id',
    };
    global.self.clients.get.mockResolvedValue(client);
    global.self.clients.matchAll.mockResolvedValue([client]);

    await addEventListener('message', {
      source: {
        id: client.id,
      },
      data: 'MOCK_ACTIVATE',
    });

    expect(mockSendToClient).toHaveBeenCalledWith(client, { type: 'MOCKING_ENABLED', payload: true });
  });

  test('should handle CLIENT_CLOSED message and unregister when no more clients', async () => {
    const client = {
      id: 'test_id',
    };
    global.self.clients.get.mockResolvedValue(client);
    global.self.clients.matchAll.mockResolvedValue([]);

    await addEventListener('message', {
      source: {
        id: client.id,
      },
      data: 'CLIENT_CLOSED',
    });

    expect(mockUnregister).toHaveBeenCalled();
  });
});
